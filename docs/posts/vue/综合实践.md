---
title: 综合实践
---
### 1. 如何扩展一个组件

- 按照 `逻辑扩展` 和 `内容扩展` 来列举
  - 逻辑扩展：mixins, extends, composition api
  - 内容扩展：slots

- 扩展的话，可以从两个方面来看。如果是对组件进行逻辑扩展，我会使用 `mixins` 或者 `composition api`；如果是对组件进行内容扩展，我会使用 `slots` 插槽。
- 在Vue2中，使用 `mixins` 进行逻辑混入非常方便，但是也存在一些问题。例如，当同时存在多个 `mixins`时，它们可能会有冲突，内部定义的变量名称可能会重复。也有可能 `mixins` 中的变量方法名称与本地组件中的变量方法名称发生冲突，这样就会让 `mixins` 这种形式显得来源不明。在这种情况下，使用 vue3 的 `composition api` 是一种更好的选择。在Vue3中，可以将需要扩展或者复用的逻辑封装成一个 `hook`，在引入的时候通过 `usexxx` 的方式将它引入，然后通过解构的形式取出需要使用的变量/方法。

  ```js
    // 需要复用的逻辑 XXX
    function useXXX(params) {}

    // 需要复用的逻辑 YYY
    function useYYY(params) {}

    // 逻辑组合
    const component = () => {
        setup() {
            const { xxx } = useXXX();
            const { yyy } = useYYY();

            return {
                x: xxx,
                y: yyy
            }
        }
    }
  ```

- 内容扩展就比较简单，直接使用 `slots` 插槽即可。插槽也分为 `匿名插槽` 和 `具名插槽` 和 `作用域插槽`。

### 2. 子组件是否可以直接改变父组件的数据

- 单向数据流原则：
  - 官方文档中有说明，父级 `props` 的更新会向下流动到子组件中，反过来则不行。这样的原则会防止子组件意外地修改父级 `props`，造成数据流向难以理解和管理。
  - 另外，每次父组件发生更新时，子组件中的`props`都会刷新为最新值，所以不应该直接在子组件中直接修改`props`的值。
  - **当然props这个值是readonly的，无法被修改。**

- 常见的需要修改 `props` 的场景：
  - 传递一个初始值，在子组件中需要对这个值进行读写 → 用另一个变量去保存它
  - 传递一个原始值，在子组件中需要进行转换 → 在子组件中使用计算属性 `computed`

- 实践中的用法：
  - 在子组件中派发一个 `emit`，去通知父组件改变状态。
  - 父组件更新状态之后，按照单向数据流的原则，子组件接收到的 `props`会被刷新到最新的值。